/**
 * Configuration API Routes
 * Secure API configuration management
 * @module backend/api/routes
 */

import { Router, Request, Response } from 'express';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { body, validationResult } = require('express-validator');
import { backendSecrets } from '../../config/secrets.config';
import { stripeService } from '../../services/stripe.service';
import fs from 'fs/promises';
import path from 'path';

const router = Router();

/**
 * API Configuration interface
 */
interface ApiConfiguration {
  stripe: {
    configured: boolean;
    testMode: boolean;
    accountId?: string;
    country?: string;
  };
  supabase: {
    configured: boolean;
    url?: string;
    projectId?: string;
  };
  sendgrid: {
    configured: boolean;
    fromEmail?: string;
  };
  twilio: {
    configured: boolean;
    phoneNumber?: string;
  };
  openai: {
    configured: boolean;
    model?: string;
  };
}

/**
 * Configuration update request
 */
interface ConfigUpdateRequest {
  service: 'stripe' | 'supabase' | 'sendgrid' | 'twilio' | 'openai';
  config: Record<string, string>;
}

/**
 * Get current API configuration status
 * GET /api/config
 */
router.get('/', async (req: Request, res: Response) => {
  try {
    const config: ApiConfiguration = {
      stripe: {
        configured: !!backendSecrets.stripe.secretKey && !!backendSecrets.stripe.webhookSecret,
        testMode: backendSecrets.stripe.secretKey?.startsWith('sk_test_') || false,
      },
      supabase: {
        configured: !!backendSecrets.supabase.url && !!backendSecrets.supabase.serviceRoleKey,
        url: backendSecrets.supabase.url,
        projectId: backendSecrets.supabase.url?.split('//')[1]?.split('.')[0],
      },
      sendgrid: {
        configured: !!backendSecrets.sendgrid.apiKey,
        fromEmail: backendSecrets.sendgrid.fromEmail,
      },
      twilio: {
        configured: !!backendSecrets.twilio.accountSid && !!backendSecrets.twilio.authToken,
        phoneNumber: backendSecrets.twilio.phoneNumber,
      },
      openai: {
        configured: !!backendSecrets.openai.apiKey,
        model: backendSecrets.openai.model,
      },
    };

    // Test Stripe connection if configured
    if (config.stripe.configured) {
      try {
        const isConnected = await stripeService.testConnection();
        if (isConnected) {
          const accountInfo = await stripeService.getAccountInfo();
          config.stripe.accountId = accountInfo.id;
          config.stripe.country = accountInfo.country;
        }
      } catch (error) {
        console.error('Stripe connection test failed:', error);
      }
    }

    res.json({
      success: true,
      data: config,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Config retrieval failed:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve configuration',
    });
  }
});

/**
 * Update API configuration
 * POST /api/config/save
 */
router.post('/save', [
  body('service').isIn(['stripe', 'supabase', 'sendgrid', 'twilio', 'openai']),
  body('config').isObject(),
], async (req: Request, res: Response) => {
  try {
    // Validate request
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Invalid request data',
        details: errors.array(),
      });
    }

    const { service, config }: ConfigUpdateRequest = req.body;

    // Read current .env.backend file
    const envPath = path.join(process.cwd(), '.env.backend');
    let envContent = '';
    
    try {
      envContent = await fs.readFile(envPath, 'utf-8');
    } catch (error) {
      // File doesn't exist, create new content
      envContent = '# Backend Environment Variables\n# Generated by BookingTMS Backend API\n\n';
    }

    // Update environment variables based on service
    const updatedEnv = updateEnvContent(envContent, service, config);

    // Write updated content back to file
    await fs.writeFile(envPath, updatedEnv, 'utf-8');

    // Test the new configuration
    let testResult = { success: false, message: 'Configuration saved but not tested' };
    
    if (service === 'stripe') {
      try {
        // Temporarily update process.env for testing
        if (config.STRIPE_SECRET_KEY) process.env.STRIPE_SECRET_KEY = config.STRIPE_SECRET_KEY;
        if (config.STRIPE_WEBHOOK_SECRET) process.env.STRIPE_WEBHOOK_SECRET = config.STRIPE_WEBHOOK_SECRET;
        
        const isConnected = await stripeService.testConnection();
        testResult = {
          success: isConnected,
          message: isConnected ? 'Stripe connection successful' : 'Stripe connection failed',
        };
      } catch (error) {
        testResult = {
          success: false,
          message: `Stripe test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        };
      }
    }

    return res.json({
      success: true,
      message: `${service.toUpperCase()} configuration saved successfully`,
      test: testResult,
      timestamp: new Date().toISOString(),
    });

  } catch (error) {
    console.error('Config save failed:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to save configuration',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * Test API service connection
 * POST /api/config/test/:service
 */
router.post('/test/:service', async (req: Request, res: Response) => {
  try {
    const { service } = req.params;
    let testResult = { success: false, message: 'Service not supported', details: {} };

    switch (service) {
      case 'stripe':
        try {
          const isConnected = await stripeService.testConnection();
          if (isConnected) {
            const accountInfo = await stripeService.getAccountInfo();
            testResult = {
              success: true,
              message: 'Stripe connection successful',
              details: {
                accountId: accountInfo.id,
                country: accountInfo.country,
                businessType: accountInfo.business_type,
                chargesEnabled: accountInfo.charges_enabled,
                payoutsEnabled: accountInfo.payouts_enabled,
              },
            };
          } else {
            testResult = {
              success: false,
              message: 'Stripe connection failed',
              details: {},
            };
          }
        } catch (error) {
          testResult = {
            success: false,
            message: `Stripe test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            details: {},
          };
        }
        break;

      default:
        testResult = {
          success: false,
          message: `Testing for ${service} not implemented yet`,
          details: {},
        };
    }

    res.json({
      success: testResult.success,
      service,
      test: testResult,
      timestamp: new Date().toISOString(),
    });

  } catch (error) {
    console.error('Service test failed:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to test service',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * Get Stripe public configuration
 * GET /api/config/stripe/public
 */
router.get('/stripe/public', (req: Request, res: Response) => {
  try {
    const publicConfig = stripeService.getPublicConfig();
    
    res.json({
      success: true,
      data: publicConfig,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Stripe public config retrieval failed:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve Stripe public configuration',
    });
  }
});

/**
 * Update environment file content
 */
function updateEnvContent(content: string, service: string, config: Record<string, string>): string {
  let lines = content.split('\n');
  
  // Define environment variable mappings for each service
  const serviceVars: Record<string, string[]> = {
    stripe: ['STRIPE_SECRET_KEY', 'STRIPE_PUBLISHABLE_KEY', 'STRIPE_WEBHOOK_SECRET'],
    supabase: ['SUPABASE_URL', 'SUPABASE_SERVICE_ROLE_KEY'],
    sendgrid: ['SENDGRID_API_KEY', 'SENDGRID_FROM_EMAIL', 'SENDGRID_FROM_NAME'],
    twilio: ['TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_PHONE_NUMBER'],
    openai: ['OPENAI_API_KEY', 'OPENAI_ORG_ID', 'OPENAI_MODEL'],
  };

  const varsToUpdate = serviceVars[service] || [];

  // Update existing variables or add new ones
  varsToUpdate.forEach(varName => {
    if (config[varName]) {
      const existingIndex = lines.findIndex(line => line.startsWith(`${varName}=`));
      const newLine = `${varName}=${config[varName]}`;
      
      if (existingIndex !== -1) {
        lines[existingIndex] = newLine;
      } else {
        // Add new variable in appropriate section
        const sectionComment = `# ${service.toUpperCase()} Configuration`;
        const sectionIndex = lines.findIndex(line => line.includes(sectionComment));
        
        if (sectionIndex !== -1) {
          lines.splice(sectionIndex + 1, 0, newLine);
        } else {
          // Add new section
          lines.push('', sectionComment, newLine);
        }
      }
    }
  });

  return lines.join('\n');
}

export default router;
